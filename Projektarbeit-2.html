<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Laura Fraticelli">
<meta name="dcterms.date" content="2024-01-20">

<title>quarto-input104c86a2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Projektarbeit_files/libs/clipboard/clipboard.min.js"></script>
<script src="Projektarbeit_files/libs/quarto-html/quarto.js"></script>
<script src="Projektarbeit_files/libs/quarto-html/popper.min.js"></script>
<script src="Projektarbeit_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Projektarbeit_files/libs/quarto-html/anchor.min.js"></script>
<link href="Projektarbeit_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Projektarbeit_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Projektarbeit_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Projektarbeit_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Projektarbeit_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><div style="text-align: center;">
<h1 style="font-size: 2em;">
Optimale Routenplanung für Volksschulen in Zürich
</h1>
<h2 style="font-size: 1em;" class="anchored">
Nähe zu Musikschulen effizient erschließen
</h2>
</div></h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Laura Fraticelli </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 20, 2024</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<div class="g-col-9" style="text-align: justify;">
<section id="zusammenfassung" class="level3">
<h3 class="anchored" data-anchor-id="zusammenfassung">Zusammenfassung</h3>
<p>Die vorliegende Projektarbeit nutzt Methoden der Netzwerkanalyse und Programmierung zur Untersuchung von Schulwegen in der Stadt Zürich. Geodaten von Volksschulen und Musikschulen wurden über die offizielle Website der Stadt Zürich extrahiert und in ein Strassennetz integriert, wobei das OSMnx-Paket in Python eine zentrale Rolle spielte. Die Analyse umfasste die Berechnung kürzester Wege, Reisezeiten und Distanzen zwischen Volksschulen und Musikschulen. Die finale Visualisierung erfolgte in QGIS, wobei ein Fokus auf der Identifizierung von Musikvierteln und den am häufigsten besuchten Musikschulen lag. Die Schwierigkeiten bei der Datenbeschaffung zu Schüler:innenzahlen pro Schulhaus sowie Herausforderungen bei der Zentralitätsmasse und Routeninterpolation wurden transparent dargelegt. Die Arbeit ermöglicht Einblicke in Schulwege, Besuchshäufigkeiten von Musikschulen und betont die Bedeutung von verfügbaren Datenqualitäten für umfassende Analysen.</p>
</section>
<section id="einleitung" class="level3">
<h3 class="anchored" data-anchor-id="einleitung">1 Einleitung</h3>
<p>Mit vorliegender Projektarbeit sollen die im Modul “Angewandte Geoinformatik HS23” erworbenen Methoden vertieft angewendet werden. Der Schwerpunkt liegt auf der Integration von Netzwerkanalyse und Programmierung zur Analyse von Schulwegen und Musikschulbesuchen in der Stadt Zürich. Die angewandten Methoden umfassen die Extraktion und Integration von Geodaten, die Nutzung von OSMnx zur Verarbeitung von Strassennetzen und die Anwendung von Netzwerkanalyse-Techniken zur Berechnung kürzester Wege, Reisezeiten und Distanzen zwischen Bildungseinrichtungen. Die Arbeit dient nicht nur der Anwendung theoretischer Kenntnisse, sondern auch der Identifizierung und Überwindung praktischer Herausforderungen im Umgang mit realen Geodaten. Dieser Kontext betont die praktische Relevanz der angewandten Geoinformatikmethoden und fördert ein tieferes Verständnis für deren Anwendung in konkreten, komplexen Szenarien.</p>
<section id="aufgabenstellung-und-zielsetzung" class="level4">
<h4 class="anchored" data-anchor-id="aufgabenstellung-und-zielsetzung">1.1 Aufgabenstellung und Zielsetzung</h4>
<p>Für die Vertiefung und Anwendung der erlernten Methoden sollen zwei thematische Blöcke des Moduls ausgewählt und in das Projekt integriert werden. Dabei soll ein besonderer Fokus auf der GIS-Theorie liegen. Mit dem Projekt soll eine optimale Routenplanung für sämtliche Volksschulen in der Stadt Zürich zu den jeweils nächstgelegenen Musikschulen entwickelt werden. Im Fokus steht die Ermittlung der schnellsten Route von den einzelnen Schulhäusern zu den identifizierten Standorten der Musikschulen, wobei diverse Einflussfaktoren wie Verkehrsbedingungen und die Topologie des Strassennetzwerks systematisch berücksichtigt werden sollen. Das Hauptanliegen besteht darin, sicherzustellen, dass jede Schülerin und jeder Schüler die nächstgelegene Musikschule besuchen kann, ohne dabei die gesamte Stadt durchqueren zu müssen. In einem weiteren Schritt sollen diejenigen Musikschulen, die am meisten besucht werden als eine Art «Hotspots» markiert werden. Dies ermöglicht eine zusätzliche Bewertung der Zugänglichkeit der Musikschulen unter Berücksichtigung ihrer geografischen Verteilung einer Häufigkeit. Dieses Projekt vereint Aspekte der Netzwerkanalyse, Programmierung und Geodatenverarbeitung, um eine effiziente und zugängliche Verbindung zwischen den Bildungseinrichtungen herzustellen.</p>
</section>
<section id="fragestellung" class="level4">
<h4 class="anchored" data-anchor-id="fragestellung">1.2 Fragestellung</h4>
<p>Unter Berücksichtigung der oben genannten Ausgangslage und Zielsetzung wurden die folgenden Forschungsfragen formuliert: 1. Wie gross ist die Distanz zwischen der jeweiligen Volksschule und der Musikschule? 2. Wie viel Zeit nimmt diese Distanz in Anspruch? 3. Welches ist die am häufigsten besuchte Musikschule? 4. Wo liegen die Musikviertel-Hotspots?</p>
</section>
</section>
<section id="methodik" class="level3">
<h3 class="anchored" data-anchor-id="methodik">2 Methodik</h3>
<p>Im Rahmen der vorgegebenen Aufgabenstellung, greift die vorliegende Untersuchung auf die Disziplinen der Netzwerkanalyse und des Programmierens als methodische Grundlagen zurück. Die Datenbasis für dieses Projekt besteht aus Geodaten, die Informationen über die Volksschulen und Musikschulen der Stadt Zürich beinhalten. Der Datenbezug erfolgte über die offizielle Website der Stadt Zürich, wobei die Daten der Volksschulen und Musikschulen in Form von Geopackeges bereitgestellt wurden und als puktbasierte Datensätze heruntergeladen werden konnten. Ein entscheidender Schritt in der Umsetzung dieser Arbeit besteht darin, das Strassennetz der Stadt Zürich mithilfe der OpenStreetMap – Daten zu integrieren. Dies erfolgte unter Verwendung des Python – Pakets “OSMnx”, das fünf essenzielle Funktonen zur Verfügung stellt.</p>
<ol type="1">
<li><p>Automatisiertes Herunterladen von politischen Grenzen und Gebäudegrundrissen: Mithilfe von OSMnx können Ortsgeometrien von OpenStreetMap für beliebige Standorte weltweit mit nur einer Zeile Python-Code heruntergeladen und visualisiert werden.</p></li>
<li><p>Massgeschneidertes und automatisiertes Herunterladen und Erstellen von Strassennetzdaten: OSMnx erleichtert den Datenbezug von Strassennetzen, die daraufhin direkt in Python geplottet werden können.</p></li>
<li><p>Die algorithmische Korrektur von Netzwerktopologien: Die Netzwerktopologie bezieht sich auf die räumliche Anordnung und Verbindung von Strassenelementen im Netzwerk, wie Strassen, Kreuzungen, Einbahnstrassen und Fussgängerwege. OSMnx verwendet verschiedene Algorithmen, um die Rohdaten von OpenStreetMap in ein konsistentes und präzises Strassennetzwerk zu überführen.</p></li>
<li><p>Das Speichern der bearbeiteten Strassennetze als Shapefile-Datei: Die durch OSMnx bearbeiteten Strassennetze können als Shapefile-Datei mit Knoten und Kanten gespeichert werden. Dies ermöglicht weitere Bearbeitungsschritte in einer GIS-Umgebung.</p></li>
<li><p>Die Analyse von Strassennetzen und Durchführung von Berechnungen: OSMnx bietet die Möglichkeit, Strassennetze zu analysieren, einschliesslich der Berechnung von Routen, der Projektion und Visualisierung von Netzen sowie der Durchführung von Berechnungen metrischer und topologischer Masse. Diese Funktionalitäten erlauben eine umfassende Untersuchung und Auswertung der Strassennetze im Kontext des Projekts (Boeing, 2017).</p></li>
</ol>
<p>Um eine einheitliche Referenz für die Analyse zu gewährleisten, erfolgt die Transformation des erstellten Strassennetzes in das Koordinatensystem EPSG:2056. Mit dem Ziel, dass Kinder möglichst eigenständig von ihren Schulen zur Musikschule gelangen können, wurde zusätzlich der Netzwerktyp “Walk” implementiert. Dieser Netzwerktyp gibt dem Programm an, dass sich die Personen zu Fuss von einem Punkt zu einem anderen Punkt bewegen. Das vereinfachte Strassennetz sowie die hinzugefügten Standorte der Volks- und Musikschulen wurden anschliessend visualisiert, wobei das Strassennetz in Grau dargestellt wird. Die gelben Punkte repräsentieren die entsprechenden Knotenpunkte des Strassennetzes, während in Grün die Volksschulen und in Blau die Standorte der Musikschulen abgebildet sind <a href="#fig-1">Figure&nbsp;1</a>. Um eine übersichtliche Visualisierung mit gut ersichtlichen Farben zu erstellen, wurden die CMYK-Farbcodes verwendet. Die Implementierung des Strassennetzes mit dem OSMnx – Paket wurde nach Anleitung von Geoff Boeing aus seinem Artikel von 2016 realisiert (Boeing, 2016). Die Visualisierung erfolgte ebenfalls unter Anwendung der Methoden und Informationen, die in einem Beitrag von Geoff Boeing auf GitHub bereitgestellt wurden (Boeing, 2024).</p>
</section>
</div>
<div class="cell" data-tags="[]" data-execution_count="2">
<details>
<summary>Visualisierung des Strassennetzes der Stadt Zürich inklusive der Standorte der Volks- und Musikschulen</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Laden der Daten</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> ox.graph_from_place(<span class="st">'Zurich, Switzerland'</span>, network_type<span class="op">=</span><span class="st">'walk'</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformation des Graphen in das Koordinatensystem EPSG:2056</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>target_crs <span class="op">=</span> <span class="st">'EPSG:2056'</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> ox.project_graph(G, to_crs<span class="op">=</span>target_crs)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>G2 <span class="op">=</span> ox.consolidate_intersections(G, tolerance<span class="op">=</span><span class="dv">10</span>, rebuild_graph<span class="op">=</span><span class="va">True</span>, dead_ends<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>G2 <span class="op">=</span> ox.project_graph(G2, to_crs<span class="op">=</span>target_crs)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Die Punkte der Volks- und Musikschulen mit dem Koordinatensystem Karte der Stadt Zürich gleichstellen</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>volksschule <span class="op">=</span> volksschule.to_crs(G.graph[<span class="st">'crs'</span>])</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>musikschule <span class="op">=</span> musikschule.to_crs(G.graph[<span class="st">'crs'</span>])</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualisieren des Strassennetzes der Stadt Zürich</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>ox.plot_graph(G2, bgcolor<span class="op">=</span><span class="st">'#E4E8EB'</span>, edge_color<span class="op">=</span><span class="st">'#97989C'</span>, node_color<span class="op">=</span><span class="st">'#FAE386'</span>, node_size<span class="op">=</span><span class="dv">2</span>, edge_linewidth<span class="op">=</span><span class="fl">0.5</span>, ax<span class="op">=</span>ax, show<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot der Volks- und Musikschulen</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>volksschule.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#60BD63'</span>, markersize<span class="op">=</span><span class="dv">30</span>, label<span class="op">=</span><span class="st">'Volksschule'</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>musikschule.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#7443C4'</span>, markersize<span class="op">=</span><span class="dv">30</span>, label<span class="op">=</span><span class="st">'Musikschule'</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Hinzufügen des Nordpfeils oben links</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>arrow_props <span class="op">=</span> <span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'black'</span>, width<span class="op">=</span><span class="dv">2</span>, headwidth<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'N'</span>, xy<span class="op">=</span>(<span class="fl">0.05</span>, <span class="fl">0.95</span>), xytext<span class="op">=</span>(<span class="fl">0.05</span>, <span class="fl">0.9</span>), arrowprops<span class="op">=</span>arrow_props, fontsize<span class="op">=</span><span class="dv">16</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Hinzufügen des Maßstabs mit Einheit "km"</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>scalebar <span class="op">=</span> ScaleBar(dx<span class="op">=</span><span class="dv">1</span>, units<span class="op">=</span><span class="st">'m'</span>, length_fraction<span class="op">=</span><span class="fl">0.1</span>, height_fraction<span class="op">=</span><span class="fl">0.01</span>, location<span class="op">=</span><span class="st">'lower left'</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>ax.add_artist(scalebar)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'netzwerk_zuerich.png'</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="g-col-3">
<div id="fig-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="netzwerk_zuerich.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Visualisierung des Netzwerks der Stadt Zürich mit den Volksschulen in grün und den Musikschulen in blau. Abbildung wurde selber in Python erstellt.</figcaption>
</figure>
</div>
</div>
<div class="g-col-9" style="text-align: justify;">
<p>Nach der Integration des Strassennetzes durch OSMnx erfolgte die Identifikation der kürzesten Wege, minimalen Reisezeiten und Distanzen zwischen den Volksschulen und den Musikschulen. Dabei wurde für jede Volksschule der geografische Punkt abgerufen, und der nächstgelegene Knoten im Strassennetz mithilfe von OSMnx gefunden. Zudem wurden Variablen für die kürzeste Reisezeit, Distanz, Musikschule und dazugehörige Geometrie initialisiert. In Python durchläuft eine innere Schleife jede Musikschule, für die der nächstgelegene Knoten im Strassennetz gefunden wird. Unter der Verwendung von NetworkX wurde jeweils der kürzeste Weg zwischen der Volksschule und der Musikschule berechnet, wobei Distanz und Reisezeit berücksichtigt wurden. Die erhaltenen Ergebnisse wurden anschliessend visualisiert und können in den Resultaten eingesehen werden. Zur Umsetzung des zweiten Codes wurden ebenfalls Informationen aus einem Beitrag von Geoff Boeing auf GitHub bezogen (Boeing, 2023).</p>
</div>
<div class="cell" data-execution_count="4">
<details>
<summary>Visualisierung des Strassennetzes der Stadt Zürich inklusive der erstellten Routen zwischen den Standorten der Volks- und Musikschulen</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Erstellen eines leeren DataFrames, um die Ergebnisse zu speichern</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>nearest_music_schools <span class="op">=</span> gpd.GeoDataFrame(columns<span class="op">=</span>[<span class="st">'Volksschule_Name'</span>, <span class="st">'Musikschule_Name'</span>, <span class="st">'Travel_Time'</span>, <span class="st">'Travel_Distance'</span>, <span class="st">'geometry'</span>])</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Iterieren durch jede Volksschule und finden der am nächsten gelegene Musikschule</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _, volks_row <span class="kw">in</span> volksschule.iterrows():</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    origin_point <span class="op">=</span> volks_row[<span class="st">'geometry'</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    origin_node <span class="op">=</span> ox.distance.nearest_nodes(G2, origin_point.x, origin_point.y)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialisieren von Variablen für die kürzeste Distanz und die zugehörige Musikschule</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    shortest_distance <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    shortest_route <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    nearest_music_school <span class="op">=</span> <span class="va">None</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    nearest_music_school_geometry <span class="op">=</span> <span class="va">None</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _, musik_row <span class="kw">in</span> musikschule.iterrows():</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        dest_point <span class="op">=</span> musik_row[<span class="st">'geometry'</span>]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        dest_node <span class="op">=</span> ox.distance.nearest_nodes(G2, dest_point.x, dest_point.y)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Finden des kürzesten Weges, der kürzesten Reisezeit sowie der Distanz zwischen Volksschule und Musikschule</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            route <span class="op">=</span> nx.shortest_path(G2, origin_node, dest_node, weight<span class="op">=</span><span class="st">'length'</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Überprüfung, ob die Route mindestens zwei Punkte enthält</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(route) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>                travel_time <span class="op">=</span> nx.shortest_path_length(G2, origin_node, dest_node, weight<span class="op">=</span><span class="st">'time'</span>)</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Überprüfung, ob dies die kürzeste Distanz istf</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> travel_time <span class="op">&lt;</span> shortest_distance:</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                    shortest_distance <span class="op">=</span> travel_time</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                    nearest_music_school <span class="op">=</span> musik_row[<span class="st">'name'</span>]</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                    nearest_music_school_geometry <span class="op">=</span> LineString([(G2.nodes[node][<span class="st">'x'</span>], G2.nodes[node][<span class="st">'y'</span>]) <span class="cf">for</span> node <span class="kw">in</span> route])</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                    travel_distance <span class="op">=</span> nx.shortest_path_length(G2, origin_node, dest_node, weight<span class="op">=</span><span class="st">'length'</span>)</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> travel_distance <span class="op">&lt;</span> shortest_route:</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>                        shortest_route <span class="op">=</span> travel_distance</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> nx.NetworkXNoPath:</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Keine Verbindung zwischen Volksschule und Musikschule gefunden</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">pass</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Hinzufügen der Ergebnisse für diese Volksschule zum Gesamtergebnis</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    nearest_music_schools <span class="op">=</span> pd.concat([nearest_music_schools, pd.DataFrame({</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Volksschule_Name'</span>: [volks_row[<span class="st">'name'</span>]],</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Musikschule_Name'</span>: [nearest_music_school],</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Travel_Time'</span>: [shortest_distance],</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        <span class="st">'Travel_Distance'</span>: [shortest_route],</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        <span class="st">'geometry'</span>: [nearest_music_school_geometry]</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    })], ignore_index<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a><span class="co"># Speichern des Ergebnisses des DataFrames in eine CSV-Datei</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>nearest_music_schools.to_csv(<span class="st">'nearest_music_schools.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>ox.plot_graph(G2, bgcolor<span class="op">=</span><span class="st">'#E4E8EB'</span>, edge_color<span class="op">=</span><span class="st">'#97989C'</span>, node_color<span class="op">=</span><span class="st">'#FAE386'</span>, node_size<span class="op">=</span><span class="dv">4</span>, edge_linewidth<span class="op">=</span><span class="fl">0.5</span>, ax<span class="op">=</span>ax, show<span class="op">=</span><span class="va">False</span>, close<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>volksschule.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#60BD63'</span>, markersize<span class="op">=</span><span class="dv">30</span>, label<span class="op">=</span><span class="st">'Volksschule'</span>)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>musikschule.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#7443C4'</span>, markersize<span class="op">=</span><span class="dv">30</span>, label<span class="op">=</span><span class="st">'Musikschule'</span>)</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>nearest_music_schools.plot(ax<span class="op">=</span>ax, color<span class="op">=</span><span class="st">'#F2687D'</span>, markersize<span class="op">=</span><span class="dv">50</span>, label<span class="op">=</span><span class="st">'Nearest Music School'</span>)</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a><span class="co"># Hinzufügen des Nordpfeils oben links</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>arrow_props <span class="op">=</span> <span class="bu">dict</span>(facecolor<span class="op">=</span><span class="st">'black'</span>, width<span class="op">=</span><span class="dv">2</span>, headwidth<span class="op">=</span><span class="dv">8</span>)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>ax.annotate(<span class="st">'N'</span>, xy<span class="op">=</span>(<span class="fl">0.05</span>, <span class="fl">0.95</span>), xytext<span class="op">=</span>(<span class="fl">0.05</span>, <span class="fl">0.9</span>), arrowprops<span class="op">=</span>arrow_props, fontsize<span class="op">=</span><span class="dv">16</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'center'</span>)</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="co"># Hinzufügen des Maßstabs mit Einheit "km"</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>scalebar <span class="op">=</span> ScaleBar(dx<span class="op">=</span><span class="dv">1</span>, units<span class="op">=</span><span class="st">'m'</span>, length_fraction<span class="op">=</span><span class="fl">0.1</span>, height_fraction<span class="op">=</span><span class="fl">0.01</span>, location<span class="op">=</span><span class="st">'lower left'</span>)</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>ax.add_artist(scalebar)</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">'lower right'</span>)</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Nearest Music School for each Primary School'</span>)</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>plt.savefig(<span class="st">'routen_zuerich.png'</span>)</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="g-col-9" style="text-align: justify;">
<p>In einem weiteren Schritt wurden die Häufigkeiten der individuell frequentierten Musikschulen ermittelt, wobei ein besonderer Fokus auf die am häufigsten besuchte Musikschule gelegt wurde. Zusätzlich wurde die durchschnittliche Distanz von den betroffenen Volksschulen zur am häufigsten frequentierten Musikschule berechnet. Die erlangten Ergebnisse wurden präzise dokumentiert und in einer strukturierten Tabelle abgespeichert. Im Bestreben, die “Musikviertel” zu visualisieren und einen räumlichen Bezug herzustellen, wurden die mittels Python aufbereiteten Daten als Shapefiles abgelegt. Diese geografischen Datensätze ermöglichten somit eine Integration und Weiterverarbeitung in QGIS. Für eine klare Eingrenzung des Untersuchungsgebietes, wurde zusätzlich die Grenze der Stadt Zürich in Form eines Shapefiles in QGIS geladen. Ursprünglich war geplant, eine Zentralitätsmasse in Form einer degree – centrality durchzuführen, um die Anzahl der Verbindungen zu den Musikschulen zu quantifizieren. Bedauerlicherweise scheiterte die Interpolation der Routen unter Verwendung des SAGA – Pakets. Als Alternative wurde die bestehende Tabelle der Musikschulen mit den aus Python gewonnenen Daten erweitert und nach Häufigkeiten klassifiziert. QGIS diente hierbei vorwiegend der visuellen Darstellung des Endresultats, um die räumlichen Muster der Musikkultur in der Stadt Zürich anschaulich zu präsentieren.</p>
</div>
<div class="cell" data-execution_count="5">
<details>
<summary>Die am häufigsten besuchte Musikschule herausfiltern</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>most_common_musikschule <span class="op">=</span> nearest_music_schools[<span class="st">'Musikschule_Name'</span>].value_counts().idxmax()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="6">
<details>
<summary>Berechnung der durchschnittlichen Distanz zur am häufigsten besuchten Musikschule</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>filtered_data <span class="op">=</span> nearest_music_schools[nearest_music_schools[<span class="st">'Musikschule_Name'</span>] <span class="op">==</span> most_common_musikschule]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>average_distance <span class="op">=</span> filtered_data[<span class="st">'Travel_Distance'</span>].mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="7">
<details>
<summary>Die Häufigigkeiten der besuchten Musikschulen zählen und als Tabelle abspeichern</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>musikschule_counts <span class="op">=</span> nearest_music_schools[<span class="st">'Musikschule_Name'</span>].value_counts()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Eine neue DataFrame für die Häufigkeiten erstellen</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>musikschule_haeufigkeiten <span class="op">=</span> pd.DataFrame({</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Musikschule_Name'</span>: musikschule_counts.index,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Haeufigkeit'</span>: musikschule_counts.values</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Die DataFrame nach der Häufigkeit absteigend sortieren</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>musikschule_haeufigkeiten <span class="op">=</span> musikschule_haeufigkeiten.sort_values(by<span class="op">=</span><span class="st">'Haeufigkeit'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Speichern des Ergebnisses des DataFrames in eine CSV-Datei</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>musikschule_haeufigkeiten.to_csv(<span class="st">'musikschule_haeufigkeiten.csv'</span>, index<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="resultate" class="level3 g-col-9" style="text-align: justify;">
<h3 class="anchored" data-anchor-id="resultate">Resultate</h3>
<p>Die nachfolgende Abbildung illustriert die Ergebnisse einer umfassenden Analyse, bei der mithilfe von Python die kürzesten Routen von jeder Volksschule zu ihrer am nächsten gelegenen Musikschule ermittelt wurden <a href="#fig-2">Figure&nbsp;2</a>.</p>
<div class="g-col-3">
<div id="fig-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="routen_zuerich.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Visualisierung des Netzwerks der Stadt Zürich mit den Volksschulen in Grün, den Musikschulen in Blau und den evaluierten Strecken zwischen den Schulanlagen in Pink. Die Abbildung wurde selber in Python erstellt.</figcaption>
</figure>
</div>
</div>
<p>Die Grafik präsentiert das Strassennetz in einer dezenten Graufärbung. Die gelben Punkte repräsentieren die Knotenpunkte dieses Strassennetzes. In kontrastierendem Grün sind die Standorte der Volksschulen, während die blauen Punkte die Positionen der Musikschulen visualisieren. Die herausgearbeiteten Ergebnisse der kürzesten Routen werden auf der Abbildung in Pink hervorgehoben.</p>
</section>
<div class="g-col-9" style="text-align: justify;">
<p>Um einen detaillierten Überblick über die charakteristischen Merkmale der berechneten Routen zu gewährleisten, werden die relevanten Informationen in einer anschliessenden Tabelle präsentiert <a href="#tbl-data1">Table&nbsp;1</a>. Diese Tabelle enthält spezifische Angaben zu den einzelnen Strecken in Meter sowie den ermittelten Zeit, die benötigt wird um für jede Verbindung von einer Volksschule zur Musikschule zu gelangen. Aufgrund der umfassenden Datenmenge, welche ursprünglich eine Tabellenlänge von insgesamt 125 Zeilen umfasste, wurde eine Reduzierung auf 10 Zeilen vorgenommen. Dieser Schritt erfolgte, um eine übersichtlichere und leichter erfassbare Darstellung zu gewährleisten.</p>
<div id="tbl-data1" class="anchored">
<table class="table">
<caption>Table&nbsp;1: Berechnete Routen zwischen jeder Volksschule und ihrer nächst gelegenen Musikschule in Minuten und Meter. Die Daten stammen aus eigenen Berechnungen in Python.</caption>
<colgroup>
<col style="width: 14%">
<col style="width: 21%">
<col style="width: 9%">
<col style="width: 14%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Volksschule_Name</th>
<th>Musikschule_Name</th>
<th>Travel_Time</th>
<th>Travel_Distance [m]</th>
<th>geometry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Aemtler Primar</td>
<td>MKZ Uto</td>
<td>10</td>
<td>1072.5506295534000</td>
<td>LINESTRING (2681083.335702539 1247479.4787241085,…)</td>
</tr>
<tr class="even">
<td>Bläsi</td>
<td>Musikzentrum Wehntalerstrasse</td>
<td>24</td>
<td>2368.8799866718700</td>
<td>LINESTRING (2681410.2231750716 1246965.8125060948,…)</td>
</tr>
<tr class="odd">
<td>Blumenfeld</td>
<td>Musikzentrum Wehntalerstrasse</td>
<td>10</td>
<td>924.187764971735</td>
<td>LINESTRING (2680859.9144698596 1248523.704931316,…)</td>
</tr>
<tr class="even">
<td>Bühl</td>
<td>MKZ Uto</td>
<td>7</td>
<td>654.8360595142120</td>
<td>LINESTRING (2680144.341851795 1246370.6301912204,…)</td>
</tr>
<tr class="odd">
<td>Buhnrain</td>
<td>MKZ Glattal</td>
<td>8</td>
<td>743.548844417518</td>
<td>LINESTRING (2679997.4836222166 1247275.4069550154,…)</td>
</tr>
<tr class="even">
<td>Hardau</td>
<td>MKZ Uto</td>
<td>16</td>
<td>1969.6141427563300</td>
<td>LINESTRING (2678774.165319729 1249084.6875060597,…)</td>
</tr>
<tr class="odd">
<td>Dachslern</td>
<td>Musikzentrum Wydlerweg</td>
<td>16</td>
<td>1670.6828985538200</td>
<td>LINESTRING (2685091.9141566623 1246324.4359749083,…)</td>
</tr>
<tr class="even">
<td>Utogrund</td>
<td>Musikzentrum Wydlerweg</td>
<td>10</td>
<td>1000.0622169662400</td>
<td>LINESTRING (2678549.503248693 1251839.5028549784,…)</td>
</tr>
<tr class="odd">
<td>Provisorium Borrweg</td>
<td>MKZ Letzi</td>
<td>17</td>
<td>1714.5378854598700</td>
<td>LINESTRING (2681404.4372691372 1246620.1432365621,…)</td>
</tr>
<tr class="even">
<td>Döltschihalde</td>
<td>MKZ Letzi</td>
<td>18</td>
<td>1719.9967064321000</td>
<td>LINESTRING (2678823.539779833 1248294.429774235,…)</td>
</tr>
</tbody>
</table>
</div>
<p>In einer weiteren Tabelle werden die Anzahl der Volksschulen aufgeführt, die jede einzelne Musikschule besuchen <a href="#tbl-data">Table&nbsp;2</a>. Diese tabellarische Darstellung liefert Einblicke in die Präferenzen und die Häufigkeit der Besuche der Musikschulen durch die Volksschulen im betrachteten Gebiet. Die Frequenzen bieten eine bedeutende Grundlage für weiterführende Analysen zur Beliebtheit und zur Nutzungsintensität der einzelnen Musikschulen. Die Untersuchung dieser Daten ermöglicht eine vertiefte Bewertung der Interaktionen zwischen den Volksschulen und den Musikschulen, was wiederum Schlussfolgerungen über die Attraktivität und Relevanz der Musikschulen für die Schülerschaft zulässt.</p>
<div id="tbl-data" class="anchored">
<table class="table">
<caption>Table&nbsp;2: Anzahl Volksschulen, die jeweils eine Musikschule besuchen. Die Daten stammen aus eigenen Berechnungen in Python.</caption>
<thead>
<tr class="header">
<th>ID</th>
<th>Musikschule_Name</th>
<th>Häufigkeit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>Musikzentrum Wydlerweg</td>
<td>16</td>
</tr>
<tr class="even">
<td>1</td>
<td>MKZ Waidberg</td>
<td>16</td>
</tr>
<tr class="odd">
<td>2</td>
<td>MKZ Uto</td>
<td>15</td>
</tr>
<tr class="even">
<td>3</td>
<td>MKZ Schwamendingen</td>
<td>14</td>
</tr>
<tr class="odd">
<td>4</td>
<td>Musikzentrum Manegg</td>
<td>10</td>
</tr>
<tr class="even">
<td>5</td>
<td>MKZ Zürichberg</td>
<td>10</td>
</tr>
<tr class="odd">
<td>6</td>
<td>Musikzentrum Wehntalerstrasse</td>
<td>9</td>
</tr>
<tr class="even">
<td>7</td>
<td>Musikzentrum Bläsi</td>
<td>8</td>
</tr>
<tr class="odd">
<td>8</td>
<td>MKZ Glattal</td>
<td>6</td>
</tr>
<tr class="even">
<td>9</td>
<td>MKZ Limmattal</td>
<td>5</td>
</tr>
<tr class="odd">
<td>10</td>
<td>Musikzentrum Kreuzplatz</td>
<td>4</td>
</tr>
<tr class="even">
<td>11</td>
<td>MKZ Letzi</td>
<td>3</td>
</tr>
<tr class="odd">
<td>12</td>
<td>Musikzentrum Waldgarten</td>
<td>3</td>
</tr>
<tr class="even">
<td>13</td>
<td>Musikzentrum Sperletweg</td>
<td>3</td>
</tr>
<tr class="odd">
<td>14</td>
<td>Musikzentrum Florhofgasse</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>Die vorliegende Tabelle gibt Aufschluss darüber, dass das Musikzentrum Wydlerweg und das MKZ Waidberg mit jeweils 16 nahegelegenen Volksschulen die höchste Besuchsfrequenz aufweisen. Dies deutet darauf hin, dass diese Musikschulen als besonders präferierte Anlaufstellen für Bildungseinrichtungen fungieren. Diese Erkenntnisse ermöglichen eine genauere Betrachtung der Beziehungen zwischen den Musikschulen und den angeschlossenen Volksschulen.</p>
<p>Zur abschliessenden Visualisierung der Ergebnisse wurde ein spezifisches Layout in QGIS entwickelt, welches im Anhang ersichtlich ist <a href="#fig-3">Figure&nbsp;3</a>. Diese Visualisierung bietet eine übersichtliche und anschauliche Darstellung der räumlichen Verteilung und der Intensität der Verbindungen zwischen den Volksschulen und den besuchten Musikschulen im untersuchten Gebiet.</p>
<div class="g-col-3">
<div id="fig-3" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="QGIS_fertig.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3: Layout aus QGIS mit der visualisierten Besucherdichte in den jeweiligen Musikschulen und den dadurch evaluierten “Musikviertel”. Die Darstellung wurde selber in QGIS erstellt.</figcaption>
</figure>
</div>
</div>
<p>Die dargebotene Abbildung präsentiert ein geographisches Informationssystem (GIS) der Stadt Zürich, welches mehrere relevante räumliche Komponenten integriert. Das OpenStreetMap (OSM)-Strassennetz bildet das grundlegende Gerüst, welches die topologischen Beziehungen zwischen den verschiedenen Orten veranschaulicht. Die Gemeindegrenzen der Stadt Zürich bieten einen geografischen Kontext für die Untersuchung.</p>
<p>Die Volksschulen und Musikschulen werden durch differenzierte Farben repräsentiert, um eine klare Unterscheidung zu ermöglichen. Die schnellsten Routen von den Volksschulen zu den entsprechenden Musikschulen werden durch pinke Linien dargestellt und erlauben eine visuelle Verfolgung der direkten Verbindungen. Besondere Beachtung erfährt die am häufigsten besuchte Musikschule, die durch einen markanten roten Punkt hervorgehoben wird. Die Klassifizierung der übrigen Musikschulen erfolgt durch abgestufte orangefarbene bis gelbe Punkte, wobei die Grösse der Kreise mit der Abnahme der Besucherzahlen korreliert. Diese visuelle Repräsentation bietet eine anschauliche Darstellung der räumlichen Verteilung und der Besuchsfrequenzen von Musikschulen durch Volksschulen in Zürich.</p>
<section id="diskussion" class="level3">
<h3 class="anchored" data-anchor-id="diskussion">Diskussion</h3>
<p>Im Verlauf der Untersuchung traten diverse methodische Herausforderungen auf, die sowohl die Datenbeschaffung als auch die geplante Analyse beeinflussten. Die Ermittlung der Schüler:innenzahlen pro Schulhaus hätte eine präzisere Bestimmung darüber ermöglicht, welche Musikschule tatsächlich die höchste Besucher:innenzahl aufweist. Die Beschaffung dieser Informationen hätten den zeitlichen und thematischen Rahmen dieser Arbeit überschritten und wurde daher nicht umgesetzt. Des Weiteren konnte die Integration eines Nordpfeils auf der durch Python generierten Karte trotz Einsatz künstlicher Intelligenz nicht erfolgreich durchgeführt werden. Die geplante Anwendung einer Zentralitätsmasse zur Visualisierung von Musikvierteln konnte aufgrund von technischen Schwierigkeiten nicht erfolgreich umgesetzt werden, da sich die Interpolation der Routen mit dem SAGA-Paket als problematisch gestaltete. Drei Musikschulen der in Python visualisierten Ergebnisse, haben aus unbekannten Gründen eine Route zueinander erstellt. Das Problem konnte in QGIS manuell entfernt werden, in Python konnte jedoch keine Lösung dafür gefunden werden. Trotz dieser Hindernisse wurde eine alternative Herangehensweise gewählt, um dennoch eine kategorisierte Visualisierung der Musikschulen zu präsentieren. Dabei wurden die Besucherhäufigkeiten der Volksschulen klassifiziert und in einem übersichtlichen Schema dargestellt. Die Musikschulen wurden dabei auf Grundlage ihrer Beliebtheit eingestuft, wobei ein dunkelroter und grösserer Punkt, die am häufigsten besuchte Musikschule repräsentiert und ein heller, kleiner Punkt die am wenigsten besuchte. Die bereinigte Tabelle der Musikschulen, diente dazu, die Daten auf eine kohärente und verständliche Weise zu präsentieren. Die gekürzte Tabelle, obgleich als exemplarische Darstellung gedacht, ermöglicht eine leichtere Erfassung der Informationen, während eine umfassendere Darstellung durch die Originaldaten gewährleistet ist.</p>
</section>
<section id="quellenverzeichnis" class="level3">
<h3 class="anchored" data-anchor-id="quellenverzeichnis">Quellenverzeichnis</h3>
<p>Boeing, G. (2016, November). OSMnx: New Methods for Acquiring, Constructing, Analyzing, and Visualizing Complex Street Networks. Goeff Boeing - Urban planning and spatial analysis professor at USC. https://geoffboeing.com/2016/11/osmnx-python-street-networks/</p>
<p>Boeing, G. (2017, Mai). OSMNX: New Methods for Acquiring, Constructing, Analyzing, and Visualizing Complex Street Networks. Computers, Environment and Urban Systems, 65, 126–139.</p>
<p>Boeing, G. (2023, November). Routing, speed imputation, and travel times [Forum]. https://github.com/gboeing/osmnx-examples/blob/main/notebooks/02-routing-speed-time.ipynb</p>
<p>Boeing, G. (2024). Osmnx/plot.py. github. https://github.com/gboeing/osmnx/blob/main/osmnx/plot.py</p>
<p>“Wie erstellt man in einer Grafik in Python einen Nordpfeil?”. ChatGPT, Version 3.5, OpenAI, 5. Jan 2024, chat.openai.com/chat.</p>
<p>“Wie erstellt man in einer Grafik in Python einen Massstab?”. ChatGPT, Version 3.5, OpenAI, 5. Jan 2024, chat.openai.com/chat.</p>
</section>
</div>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>